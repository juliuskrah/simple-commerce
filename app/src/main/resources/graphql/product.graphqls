extend type Query {
    "Find a product by its ID."
    product("Product ID" id: ID!): Product
    "Find a product variant by its ID."
    variant("Product Variant ID" id: ID!): ProductVariant
    "Find all products with optional search query using GitHub-style syntax."
    products(first: Int @Positive, after: String, last: Int @Positive, before: String,
        orderBy: [ProductOrderField], orderDirection: OrderDirection = ASC,
        "Search query using GitHub-style syntax (e.g., 'status:published price:100..200')"
        query: String):
    ProductConnection! @Expression(value : "${args.containsOneOf('first','last')}")
}

type Mutation {
    "Create a new product."
    addProduct(input: ProductInput!): Product
    "Update an existing product."
    updateProduct("Product ID" id: ID!, input: ProductInput!): Product
    "Delete a product."
    deleteProduct("Product ID" id: ID!): ID!
    "Create a new product variant."
    addProductVariant("Product ID" productId: ID!, input: ProductVariantInput!): ProductVariant
    "Update an existing product variant."
    updateProductVariant("Product Variant ID" id: ID!, input: ProductVariantInput!): ProductVariant
    "Delete a product variant."
    deleteProductVariant("Product Variant ID" id: ID!): ID!
    "Add digital content to a variant."
    addVariantDigitalContent("Product Variant ID" variantId: ID!, file: FileInput!): DigitalContent
    "Create a price set."
    addPriceSet(input: PriceSetInput!): PriceSet
    "Update an existing price set."
    updatePriceSet("Price Set ID" id: ID!, input: PriceSetInput!): PriceSet
    "Delete a price set."
    deletePriceSet("Price Set ID" id: ID!): ID!
    "Publish a draft product using state machine validation."
    publishProduct("Product ID" id: ID!): Product
    "Archive a published product."
    archiveProduct("Product ID" id: ID!): Product
    "Reactivate an archived product (moves to draft state)."
    reactivateProduct("Product ID" id: ID!): Product
}

"""
The Product object lets you manage products in a store. Products are the goods and services that are offered for sale.
They can include various details such as title, description, price, and status. You can use product variants
to create or update different versions of a product, such as different sizes or colors.

You can add or update product media. Products can be organised by grouping them into collections.
"""
type Product implements Node {
    id: ID!
    createdAt: DateTime!
    "Actor that created the product. This is a restricted field and can only be seen by users with the proper permissions."
    createdBy: Actor
    description: JsonString
    """
    The slug is a uniquely generated URI friendly identifier for a product.
    It is generated from the title of the product. A number is appended
    to the end of the slug if a product with the same slug already exists.
    """
    slug: String!
    status: ProductStatus!
    priceRange: PriceRange
    tags(limit: Int!): [String!]
    title: String!
    updatedAt: DateTime!
    "Actor that updated the product. This is a restricted field and can only be seen by users with the proper permissions."
    updatedBy: Actor
    "Product variants. Every product has at least one variant."
    variants(
        first: Int @Positive,
        after: String,
        last: Int @Positive,
        before: String,
        orderBy: [ProductVariantOrderField],
        orderDirection: OrderDirection = ASC
    ): ProductVariantConnection! @Expression(value : "${args.containsOneOf('first','last')}")
}

"A product variant represents a sellable version of a product with specific attributes like SKU and price."
type ProductVariant implements Node {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    "The product this variant belongs to."
    product: Product!
    "Stock Keeping Unit - a unique identifier for this variant."
    sku: String!
    "The title of this variant. If null, inherits from the product title."
    title: String!
    "The price of this variant."
    price: Money
    "Contextual price resolved for this variant based on provided context."
    resolvedPrice(context: PriceContextInput!): Money
    "Price sets containing contextual pricing rules for this variant."
    priceSets: [PriceSet!]!
    "Digital content associated with this variant."
    digitalContent: DigitalContent
}

extend type Category {
    """
    The products in the category. The products are sorted by the specified `orderBy` field.
    By default only direct products are returned. To include products from subcategories,
    set the `includeSubcategories` argument to `true`.
    """
    products(first: Int @Positive, after: String, last: Int @Positive, before: String,
        orderBy: [ProductOrderField], orderDirection: OrderDirection = ASC,
        includeSubcategories: Boolean = false): ProductConnection!
}

type PriceRange {
    start: Money
    stop: Money
}

"A collection of pricing rules for a product variant supporting contextual pricing."
type PriceSet {
    id: ID!
    name: String!
    priority: Int!
    active: Boolean!
    rules: [PriceRule!]!
    createdAt: DateTime!
    updatedAt: DateTime!
}

"A specific pricing rule within a price set defining pricing for a particular context."
type PriceRule {
    id: ID!
    contextType: PriceContextType!
    contextValue: String
    price: Money!
    minQuantity: Int
    maxQuantity: Int
    validFrom: DateTime
    validUntil: DateTime
    active: Boolean!
    createdAt: DateTime!
    updatedAt: DateTime!
}

"Input for specifying pricing context when resolving prices."
input PriceContextInput {
    customerGroup: String
    region: String
    currency: Currency!
    quantity: Int = 1
}

"Types of pricing contexts that can be applied to price rules."
enum PriceContextType {
    "Geographic context (country, region, state)"
    GEOGRAPHIC
    "Currency context for multi-currency pricing"
    CURRENCY
    "Customer group context for tiered pricing (B2B, B2C, VIP, etc.)"
    CUSTOMER_GROUP
    "Default pricing rule (no specific context)"
    DEFAULT
}

input ProductInput {
    description: String
    price: Decimal
    tags: [String!]
    title: String!
    status: ProductStatus = DRAFT
}

input ProductVariantInput {
    sku: String!
    title: String!
    price: MoneyInput
}

"Input for creating or updating a price set."
input PriceSetInput {
    name: String!
    priority: Int = 0
    active: Boolean = true
    rules: [PriceRuleInput!]!
}

"Input for creating or updating a price rule."
input PriceRuleInput {
    contextType: PriceContextType!
    contextValue: String
    price: MoneyInput!
    minQuantity: Int
    maxQuantity: Int
    validFrom: DateTime
    validUntil: DateTime
    active: Boolean = true
}

input MoneyInput {
    amount: Decimal!
    currency: Currency!
}

enum ProductStatus {
    DRAFT
    PUBLISHED,
    ARCHIVED
}

enum ProductOrderField {
    title
    createdAt
    updatedAt
}

enum ProductVariantOrderField {
    sku
    createdAt
    updatedAt
}
